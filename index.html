<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js - Original Movement</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                background-color: #000;
                margin: 0px;
                overflow: hidden;
            }
            #info {
                position: absolute;
                top: 10px;
                width: 100%;
                text-align: center;
                z-index: 100;
                display:block;
                color: #fff;
                font-family: Monospace;
            }
        </style>
    </head>
    <body>
        <div id="info">
            Original Camera Feel with a Single Figure
        </div>

        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
                }
            }
        </script>

        <script type="module">

            import * as THREE from 'three';
            import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
            import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
            import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

            let container, camera, scene, renderer, composer, bloomPass;
            const spheres = [];
            let mouseX = 0, mouseY = 0;
            let windowHalfX = window.innerWidth / 2;
            let windowHalfY = window.innerHeight / 2;

            const clock = new THREE.Clock();
            const mixers = [];
            const figures = [];

            init();

            function init() {
                container = document.createElement( 'div' );
                document.body.appendChild( container );

                // ✨ Camera settings exactly as per your original code
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 100 );
                camera.position.z = 3;

                scene = new THREE.Scene();

                const urls = [
                    'src/x.png', 'src/nx.png',
                    'src/y.png', 'src/ny.png',
                    'src/z.png', 'src/nz.png'
                ];
                const textureCube = new THREE.CubeTextureLoader().load( urls );
                scene.background = textureCube;
                
                const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );
                scene.add( hemiLight );
                const dirLight = new THREE.DirectionalLight( 0xffffff, 3 );
                dirLight.position.set(5, 5, 5);
                scene.add( dirLight );

                const sphereGeometry = new THREE.SphereGeometry( 0.1, 32, 16 );
                const sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );
                for ( let i = 0; i < 500; i ++ ) { // Restored to 500 spheres
                    const mesh = new THREE.Mesh( sphereGeometry, sphereMaterial );
                    // Initial random positions, as per original
                    mesh.position.x = Math.random() * 10 - 5;
                    mesh.position.y = Math.random() * 10 - 5;
                    mesh.position.z = Math.random() * 10 - 5;
                    mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1;
                    scene.add( mesh );
                    spheres.push( mesh );
                }
                
                const loader = new GLTFLoader();
                loader.load( 'https://threejs.org/examples/models/gltf/Xbot.glb', 
                    function ( gltf ) {
                        const model = gltf.scene;
                        const animations = gltf.animations;
                        const runClip = THREE.AnimationClip.findByName( animations, 'run' );
                        const numFigures = 1;
                        for ( let i = 0; i < numFigures; i++ ) {
                            const newFigure = SkeletonUtils.clone( model );
                            const mixer = new THREE.AnimationMixer( newFigure );
                            
                            if (runClip) {
                                mixer.clipAction( runClip ).play();
                            }
                            
                            mixers.push( mixer );
                            figures.push( newFigure );
                            
                            newFigure.position.set( 0, -1, 0 );
                            newFigure.rotation.y = Math.random() * Math.PI * 2;
                            newFigure.scale.set( 0.75, 0.75, 0.75 );
                            
                            scene.add( newFigure );
                        }
                    },
                    undefined,
                    function ( error ) {
                        console.error( 'An error happened while loading the model:', error );
                    }
                );

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setAnimationLoop( animate );
                container.appendChild( renderer.domElement );

                const renderScene = new RenderPass( scene, camera );
                bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 0.25, 0.1, 0.85 );
                bloomPass.threshold = 0.9;
                bloomPass.strength = 0.3;
                bloomPass.radius = 0.1;

                composer = new EffectComposer( renderer );
                composer.addPass( renderScene );
                composer.addPass( bloomPass );

                window.addEventListener( 'resize', onWindowResize );
                document.addEventListener( 'mousemove', onDocumentMouseMove );
                onWindowResize();
            }

            function onWindowResize() {
                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
                composer.setSize( window.innerWidth, window.innerHeight );
            }

            // ✨ Mouse movement logic exactly as per your original code
            function onDocumentMouseMove( event ) {
                mouseX = ( event.clientX - windowHalfX ) / 100;
                mouseY = ( event.clientY - windowHalfY ) / 100;
            }

            function animate() {
                const delta = clock.getDelta();
                const elapsedTime = clock.getElapsedTime();

                // ✨ Camera movement exactly as per your original code
                camera.position.x += ( mouseX - camera.position.x ) * .05;
                camera.position.y += ( -mouseY - camera.position.y ) * .05;
                camera.lookAt( scene.position );
                
                for ( const mixer of mixers ) {
                    mixer.update( delta );
                }

                const runSpeed = 2.0;
                for ( const figure of figures ) {
                    figure.translateZ( runSpeed * delta );
                    if ( figure.position.lengthSq() > 36 ) {
                        figure.lookAt( scene.position );
                    }
                }

                // ✨ Sphere movement exactly as per your original code
                const timer = elapsedTime * 0.1; // Using clock for smooth timing
                for ( let i = 0, il = spheres.length; i < il; i ++ ) {
                    const sphere = spheres[ i ];
                    sphere.position.x = 5 * Math.cos( timer + i );
                    sphere.position.y = 5 * Math.sin( timer + i * 1.1 );
                    // The sphere's z position is not changed, just like the original.
                }

                composer.render();
            }
        </script>
    </body>
</html>